import Mathlib.CategoryTheory.Over
import Mathlib.CategoryTheory.EqToHom
set_option autoImplicit true

namespace CategoryTheory

--open Opposite
set_option maxHeartbeats 500000
universe v₁ u₁ s₁ t₁--v₂ u₁ u₂
/-
Important: i added some remarks (search for the word Remark)
What did I show?
Firstly In the file PresheavesOfCategories, I constructed a functor

splitfibration B ⥤ PShCat B , which is of independent interest.
Originally i wanted to show, that this is a strong equivalence of 2-categories whose inverse is given by the grothendieck construction
(which i also implemented)


Secondly, the main goal was
  · a functor Sp : fibration B ⥤ splitFibration B
  · equipped with an equivalence of fibrations E: Sp P ⥤c P, which means for me a cartesian functor which is an equivalence on total categories
    (because then, which i tried to formalize, it reflects cartesian morphisms,
    which is almost as good as having a cartesian quasi-inverse functor P ⥤c Sp P)

The functor Sp factors as
  psh ≫ Grothendieck : fibration B ⥤ PShCat B ⥤ splitFibration B
  where the first map is P ↦ Fib(fundamentalfibration · , P)
  so we have to pull back the yoneda embedding at P along a functor
    fundamentalFibration : B ⥤ fibration B

I constructed functors in both directions PShCat B ⥤ splitFibration


-/
/- BOTH NOT IMPORTANT
def mappingOverHom {P Q : fibration B} (F : P ⟶ Q ) {J I} {u : J ⟶ I} {Y : P [J]} {X : P[I]} (φ : over_hom u Y X) :  over_hom u ((F / J).obj Y) ((F / I).obj X) := by
  use F.1.left.map φ.1
  let hφ := φ.2
  calc
      (Q.1).hom.map ((F.1).left.map φ.1) ≫ eqToHom (_ : Q.1.hom.obj ((F / I).obj X).1 = I)
    =  ((Q.1).hom.map ((F.1).left.map φ.1) ≫ eqToHom (symm (comm F))) ≫ eqToHom X.2 := by rw [Category.assoc] ; apply (_ ≫= · ) ; symm ; apply eqToHom_trans
  _ = (eqToHom (symm (comm F)) ≫ P.1.hom.map (φ.1)) ≫ eqToHom X.2 := by {
    have veryweird : (F.1.left ⋙ Q.1.hom).map φ.1 = (F.1.left ≫  Q.1.hom).map φ.1 := rfl
    apply (· =≫ _) ; rw [← Functor.comp_map , veryweird  ,  Functor.congr_hom (Over.w F.1) φ.1 , Category.assoc ,Category.assoc ,  eqToHom_trans , eqToHom_refl] ; aesop
  }
  _ = eqToHom (_) ≫ eqToHom (_) ≫ u := by rw [Category.assoc] ; apply (_≫= · ) ; apply φ.2
  _ = eqToHom (_ : (Q).1.hom.obj ((F / J).obj Y).1 = J) ≫ u := by rw [← Category.assoc] ; apply (· =≫ u) ; apply eqToHom_trans
  -- have this : u = Q.1.hom.map (F.1.left.map φ.1) := by sorry
/-
def cartesianMorphismToCartLift (P : Over B ) {I : B} {X : obj_over (P:=P.hom) I} { Y : P.1}  {φ : Y ⟶ X.1} (hφ : isCartesianMorphism  P φ) : cartesianLiftOfAlong X (P.hom.map φ ≫ eqToHom X.2) where
  Y := ⟨ Y , rfl⟩
  φ := ⟨ φ  , by aesop⟩
  isCart := by sorry --apply compPresCartesian -- sorry --hφ
-/

/-
def cartFunctorPresCartLifts {I : B} {X : obj_over (P:=P.1.hom) I} {u : J ⟶I } (L : cartesianLiftOfAlong X u) : cartesianLiftOfAlong ( (F / I).obj X) u := by
  let Fφ := mappingOverHom F L.φ
  let FXf :=  (F / I).obj X
  let Ff : isCartesianMorphism Q.1 (F.1.left.map L.φ.1) := F.2 L.φ.1 (cartLiftToCartMor L) --
  let FL' : cartesianLiftOfAlong (P:=Q.1.hom) FXf u  := by
      use ⟨ _ ,Fφ⟩
      let cartLift : cartesianLiftOfAlong _ (Q.1.hom.map  (F.1.left.map L.φ.1) ≫ eqToHom (_)) := cartesianMorphismToCartLift Q.1 Ff
      sorry
      --, by apply cartesianMorphismToCartLift ; sorry ⟩
  sorry
-/

/-
@[ext] def extCartLift {J I} (u : J ⟶ I) (X : obj_over (P:=P) I) (r s : cartesianLiftOfAlong X u) (q : r.1 = s.1) : r = s
  := by sorry
-/
