import Mathlib.CategoryTheory.Over
import Mathlib.CategoryTheory.EqToHom
set_option autoImplicit true

namespace CategoryTheory

--open Opposite
set_option maxHeartbeats 500000
universe v‚ÇÅ u‚ÇÅ s‚ÇÅ t‚ÇÅ--v‚ÇÇ u‚ÇÅ u‚ÇÇ

variable {ùïè : Type u‚ÇÅ} {B : Type u‚ÇÅ} [Category.{v‚ÇÅ} B] [Category.{v‚ÇÅ} ùïè] {P : ùïè ‚•§ B}
namespace FiberedCategories


def substCod {X Y Z : B} (h : Y = Z) (f : X ‚ü∂ Y) : (X ‚ü∂ Z) := f ‚â´ CategoryTheory.eqToHom h -- by rw [‚Üê h]  ; exact f
def substDom {X Y Z : B} (h : X = Y) (f : Y ‚ü∂ Z) : (X ‚ü∂ Z) := CategoryTheory.eqToHom h ‚â´ f -- by rw [h]  ; exact f




def obj_over (A : B) := {X : ùïè // P.obj X = A}
instance : CoeOut (obj_over (P:=P) A) ùïè := ‚ü®fun Œ± ‚Ü¶ Œ±.1‚ü©
@[simp] def isVertical {X X' : obj_over (P:=P) A} (Œ± : X.1 ‚ü∂ X') := P.map Œ± ‚â´ CategoryTheory.eqToHom X'.2  = CategoryTheory.eqToHom X.2
def over_hom {A A' : B} (u : A ‚ü∂ A') (X : obj_over (P:=P) A) (X' : obj_over (P:=P) A') := {
  Œ± : X.1 ‚ü∂ X' //
  P.map Œ± ‚â´ CategoryTheory.eqToHom X'.2  = CategoryTheory.eqToHom X.2 ‚â´ u
}

@[simp] lemma compPresVertical {X Y Z : obj_over (P:=P) A} (f : X.1 ‚ü∂Y.1 ) (g : Y.1 ‚ü∂ Z.1) (p : isVertical f) (q : isVertical g) :
  isVertical (f ‚â´ g ) := by
    rw [isVertical, @Functor.map_comp]
    rw [Category.assoc]
    rw [q]
    rw [p]
def idIsVertical (X : obj_over (P:=P) A) : isVertical (ùüô X.1 ) := by simp

instance : Category (obj_over ( P:= P) A) where
  Hom ( X X' : obj_over A) := { Œ± : X.1 ‚ü∂ X'.1 // isVertical (X:=X) (X':=X') Œ± } -- over_hom (ùüô A) X X' -- { Œ± : verticalOver A // Œ±.X = X ‚àß Œ±.X' = X' }
  id (X : obj_over A) := ‚ü® ùüô X.1 , idIsVertical _ ‚ü©
  comp {X} {Y} {Z} f g := ‚ü®  f.1 ‚â´ g.1 , compPresVertical f.1 g.1 f.2 g.2
     ‚ü©
def forget : (obj_over (P:=P) A) ‚•§ ùïè where
  obj := fun X ‚Ü¶ X.1
  map := fun f ‚Ü¶ f.1



@[simp] lemma compInFib {X Y Z : obj_over (P:=P) A} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : (f ‚â´ g).1 = f.1 ‚â´ g.1 := rfl
@[simp] lemma idInFib {X : obj_over (P:=P) A} : (ùüô X : X ‚ü∂ X).1 = ùüô X.1 := rfl
@[simps] def coerc { X X' : obj_over A} (f : over_hom (P:=P) (ùüô A) X X') : X ‚ü∂ X' := ‚ü® f.1 , by rw [isVertical, f.2] ; aesop ‚ü©
@[simps] def coercBack {X X' : obj_over A} (f : X ‚ü∂ X') : over_hom (P:=P) (ùüô A) X X' := ‚ü® f.1 , by rw [f.2] ; aesop‚ü©

@[ext] structure liftOfAlong {J I : B} ( X : obj_over (P:=P) I) (u : J ‚ü∂ I)  where
  Y : obj_over (P:=P) J
  œÜ : over_hom u Y X

instance : CoeDep (liftOfAlong (P:=P) X u) L (L.Y.1 ‚ü∂ X) where
  coe := L.œÜ.1
variable {J I : B} {u : J ‚ü∂ I}

@[simps] def morphismToLift {X Y : ùïè} (œÜ : Y ‚ü∂ X) : liftOfAlong ‚ü® X , rfl‚ü©  (P.map œÜ) where
  Y := ‚ü® Y , rfl‚ü©
  œÜ := by use œÜ; simp

lemma morphismToLift_coe {X Y : ùïè} (œÜ : Y ‚ü∂ X) : (morphismToLift (P:=P) œÜ).œÜ.1 = œÜ := rfl

def isCartesian  {X : obj_over (P:=P) I} (œÑ: liftOfAlong X u):=
  ‚àÄ {K : B} (v : K ‚ü∂ J) (L: liftOfAlong X (v ‚â´u )) ,
    ‚àÉ! œà : over_hom v L.Y œÑ.Y , œà.1 ‚â´ œÑ.œÜ.1 = L

def isWeakCartesian {X : obj_over (P:=P) I} (œÑ: liftOfAlong X u):= ‚àÄ (L : liftOfAlong X u) ,
  ‚àÉ! œà : L.Y ‚ü∂ œÑ.Y , œà.1 ‚â´ œÑ.œÜ.1 = L


structure cartesianLiftOfAlong {J I : B} ( X : obj_over (P:=P) I) (u : J ‚ü∂ I) extends liftOfAlong (P:=P) X u where
   isCart : isCartesian (P:=P) toliftOfAlong

instance : CoeOut (cartesianLiftOfAlong (P:=P) A u) (liftOfAlong (P:=P) A u) := ‚ü®fun Œ± ‚Ü¶ Œ±.1‚ü©

def transLift {K J I : B} {v : K ‚ü∂ J } {u : J ‚ü∂ I} {X : obj_over I}
  (Œ± : liftOfAlong X u)
  (Œ≤ : liftOfAlong (Œ±.Y) v )
  : liftOfAlong ( P:=P) X (v ‚â´ u ) where
  Y := Œ≤.Y
  œÜ := ‚ü® Œ≤.œÜ.1 ‚â´ Œ± , by rw [@Functor.map_comp, Category.assoc , Œ±.œÜ.2 , ‚Üê Category.assoc , Œ≤.œÜ.2] ; aesop_cat ‚ü©

def weakCartifCartesian {J I : B} {u : J ‚ü∂ I} {X : obj_over (P:=P) I} (œÑ: cartesianLiftOfAlong X u) : isWeakCartesian œÑ.1 := by
  intro L
  --obtain ‚ü® œÑ , isCart ‚ü©:= œÑ
  let œÑ' : liftOfAlong X (ùüô J ‚â´ u) := transLift L (‚ü® L.Y , by apply coercBack ; exact ùüô _  ‚ü©  )
  obtain ‚ü®œà, hœà ‚ü©:= œÑ.isCart (ùüô J) œÑ'
  have LeqPsiTau : œà.1 ‚â´ œÑ.œÜ.1 = L.œÜ.1 := by
    rw [hœà.1]
    apply Category.id_comp
  -- have œÅ : L.Y ‚ü∂ œÑ'.Y := ùüô (L.Y)
  use (coerc œà)
  simp
  simp at hœà
  constructor
  exact LeqPsiTau
  intro œà' hœà'
  have this : coercBack œà' = œà := by
    apply hœà.2
    rw [‚Üê hœà.1 ]
    rw [coercBack_coe]

    rw [hœà' , ‚Üê LeqPsiTau]
  apply Subtype.ext
  simp
  rw [‚Üê this]
  simp

theorem cartesianLiftIsUnique {J I : B} {u : J ‚ü∂ I} {X : obj_over (P:=P) I} (L  L' : cartesianLiftOfAlong X u) :
  ‚àÉ! Œ± : L'.1.Y ‚âÖ L.1.Y , Œ±.hom.1 ‚â´ L.1.œÜ.1 = L'.1.œÜ.1 := by
    obtain ‚ü® Œ± , hŒ±  ‚ü© := weakCartifCartesian (X:=X) L L'
    obtain ‚ü® Œ≤ , hŒ≤  ‚ü© := weakCartifCartesian (X:=X) L' L

    obtain ‚ü®œÅ , hœÅ‚ü© := weakCartifCartesian (X:=X) L' L'.1
    obtain ‚ü®œÉ , hœÉ‚ü© := weakCartifCartesian (X:=X) L L.1
    obtain ‚ü® ‚ü® Y , œÜ ‚ü© , _‚ü©   := L
    obtain ‚ü® ‚ü® Z , œà‚ü© , _‚ü©  := L'
    simp at Œ±
    simp at Œ≤
    simp at hŒ≤
    simp at hŒ±
    simp at hœÅ
    have this : (Œ± ‚â´Œ≤  ).1 = Œ±.1 ‚â´ Œ≤.1 := by rfl

    have abh : (Œ± ‚â´ Œ≤).1 ‚â´ œà.1 = œà.1  := by rw [this , Category.assoc , hŒ≤.1 , hŒ±.1]
    have abh : Œ± ‚â´Œ≤ = ùüô _ := by
      let hœÅ := hœÅ.2
      trans œÅ
      apply hœÅ
      exact abh
      symm
      apply hœÅ
      have this : (ùüô _) ‚â´ œà.1 = œà.1 := by rw [Category.id_comp]
      exact this
    have bah : (Œ≤ ‚â´Œ±  ).1 ‚â´ œÜ.1 = œÜ.1  := by calc
      _ = (Œ≤.1 ‚â´ Œ±.1) ‚â´ œÜ.1 := by rfl
      _ = Œ≤.1 ‚â´ Œ±.1 ‚â´ œÜ.1 := by rw [Category.assoc]
      _ = Œ≤.1 ‚â´ œà.1 := by rw [hŒ±.1 ]
      _ = œÜ.1 := hŒ≤.1

    have bah : Œ≤ ‚â´ Œ±= ùüô _ := by
      trans œÉ
      apply hœÉ.2
      exact bah
      symm
      apply hœÉ.2
      have this : (ùüô _) ‚â´ œÜ.1 = œÜ.1 := by rw [Category.id_comp]
      exact this
    let myiso : Z ‚âÖ Y  := ‚ü® Œ± , Œ≤ , abh, bah ‚ü©

    have h : myiso.hom = Œ± := rfl

    use myiso
    constructor
    ¬∑ simp
      exact hŒ±.1
    ¬∑ intro Œ±'  hŒ±'
      ext
      rw [h]
      --simp at hŒ±'
      apply hŒ±.2
      exact hŒ±'
      --have goa := hŒ±.2 hŒ±'

variable  {B : Cat.{v‚ÇÅ , u‚ÇÅ}}
@[ext , simp] lemma extFib {X Y : obj_over (P:=P) A } (f g : X ‚ü∂ Y) (_ : f.1 = g.1) : f = g := by apply Subtype.ext ; assumption



instance : CoeDep (Over B) F (F.1 ‚•§ B) where
  coe := F.hom
def isFibration {B : Cat.{v‚ÇÅ , u‚ÇÅ}} (P : Over B ) : Prop :=  ‚àÄ {J I : B} (u : J ‚ü∂ I) (X : obj_over (P:=P.hom) I) , ‚àÉ œÜ:  liftOfAlong (P:=P.hom) X u , isCartesian œÜ
def fibration (B : Cat.{v‚ÇÅ , u‚ÇÅ}) := { P : Over B  // isFibration P}

instance : CoeOut (fibration B) (Over B) := ‚ü® fun Œ± ‚Ü¶ Œ±.1‚ü©

instance : CoeDep (fibration B) F (F.1.1 ‚•§ B) where
  coe := F.1
def isCartesianMorphism (P : Over B ) {X Y : P.1}  (œÜ : Y ‚ü∂ X) : Prop :=
  isCartesian (P:=P.hom) (morphismToLift œÜ)
def cartesianFunctor
  (P Q : fibration B) := {F : P.1 ‚ü∂ Q.1 //
    ‚àÄ {X Y : P.1.1} (œÜ : X ‚ü∂ Y) (_ : isCartesianMorphism P.1 œÜ) ,
       isCartesianMorphism Q.1 (F.left.map œÜ)  }

scoped infixr:80 " ‚•§c   " => cartesianFunctor
@[ext] lemma extCartFunctor {P Q : fibration B} (F G : P ‚•§c Q) (p : F.1 = G.1) : F = G := Subtype.ext p
instance {P Q : fibration B} : CoeOut (P ‚•§c Q) (P.1.1 ‚•§ Q.1.1) := ‚ü®fun Œ± ‚Ü¶ Œ±.1.left‚ü©

def objMappingBetweenFibers {P Q : fibration B} (F : P.1 ‚ü∂ Q.1) {A : B} : obj_over (P:=P.1.hom) A ‚Üí obj_over (P:=Q.1.hom) A := by
  intro X
  use (F.left : P.1.left ‚•§ Q.1.left).obj X.1

  trans (F.left ‚â´ Q.1.hom).obj X.1 ; rfl ;
  have this : F.left ‚â´ Q.1.hom = P.1.hom := F.3 ;
  rw [this]
  exact X.2

variable {P Q : fibration B} {F G : P ‚•§c Q}
def isIdentity  {ùïè : Type u‚ÇÅ} [Category.{v‚ÇÅ} ùïè] {X Y : ùïè} (f : X ‚ü∂ Y) : Prop := ‚àÉ (p : X = Y) , f = eqToHom p

def toFunctorOnFibers (F : P ‚•§c Q) (A : B) :
  Functor (obj_over (P := P.1.hom) A) (obj_over (P := Q.1.hom) A) where
    obj := objMappingBetweenFibers F.1

    map := fun {X Y} (f : X ‚ü∂ Y) ‚Ü¶ by
      use (F.1.left).map f.1
      simp
      let FQ : P.1.1 ‚ü∂ B := F.1.1 ‚â´ Q.1.hom
      have this : FQ = P.1.hom := F.1.3 ;
      have myEq : (F.1.1 ‚â´ Q.1.hom).obj Y.1 = A := (objMappingBetweenFibers F.1 Y).2
      trans (FQ.map f.1 ‚â´ eqToHom myEq)
      rfl
      let myEq1 (Z : obj_over (P:=P) A) : FQ.obj Z.1 = P.1.hom.obj Z.1 := by rw [this]
      let myNat : FQ ‚ü∂ P.1.hom := eqToHom F.1.3
      have this {Y : obj_over A} : eqToHom (myEq1 Y) = myNat.app Y.1 := (eqToHom_app F.1.3 Y.1).symm
      have EqEq : myEq = (myEq1 Y).trans Y.2 := rfl
      have EqHom : eqToHom myEq = eqToHom (myEq1 Y) ‚â´ eqToHom Y.2 := by rw [EqEq] ; rw [eqToHom_trans]
      rw [EqHom, ‚Üê Category.assoc , this ,  myNat.naturality , Category.assoc , f.2 ]
      rw [‚Üê this  , eqToHom_trans]
    map_id := fun X ‚Ü¶ by apply Subtype.ext ; aesop
    map_comp := fun f g ‚Ü¶ by apply Subtype.ext ; aesop

scoped infixr:70 " / " => toFunctorOnFibers


@[simp] def rewrittenTrafo (Œ∑ : F.1.left ‚ü∂G ) {A : B} (T : obj_over (P:=P.1.hom) A) : ‚Üë((F / A).obj T).1 ‚ü∂ ‚Üë((G / A).obj T).1 :=
 (Œ∑.app T.1  : ‚Üë((F / A).obj T).1 ‚ü∂ ‚Üë((G / A).obj T).1)

def cartesianNatTrans {P Q : fibration B}
  (F G : P ‚•§c Q)
  := { Œ∑ : F.1.left ‚ü∂ G // ‚àÄ {A : B} (T : obj_over (P :=P.1.hom) A) ,
  isVertical (X:=(F / A).obj T) (X':=(G / A).obj T) (Œ∑.app T.1  ) }

scoped infixr:80 " =>c " => cartesianNatTrans
@[simp] def cartesianIdTrans : (F : P ‚•§c Q) ‚Üí  F =>c F := fun F ‚Ü¶ ‚ü®  ùüô F.1.1 , fun {A} T ‚Ü¶ idIsVertical _‚ü©


  @[simp] def compCartTrans {F G H: P ‚•§c Q} (Œ∑: F =>c G) (Œµ : G =>c H) : F =>c H := ‚ü®
     Œ∑.1 ‚â´ Œµ.1  ,
    fun T ‚Ü¶ compPresVertical _ _ (Œ∑.2 T) (Œµ.2 T)‚ü©
@[ext ,simp] lemma extCartTrafo {P Q : fibration B} {F G : P ‚•§c Q} (Œ∑ Œµ : F =>c G ) (p : Œ∑.1 = Œµ.1) : Œ∑ = Œµ  := Subtype.ext p

def trafoOnFibers (Œ∑ : F =>c G) (A : B) : F / A ‚ü∂ G / A where
  app := by
    intro X
    use rewrittenTrafo Œ∑.1 X ;
    exact (Œ∑.2 X)

  naturality := fun {X} {Y} f ‚Ü¶ by
    apply Subtype.ext
    have nat := Œ∑.1.naturality f.1
    calc
    ((F / A).map f ‚â´ ‚ü® rewrittenTrafo Œ∑.1 Y , _‚ü© ).1 = F.1.left.map f.1 ‚â´ rewrittenTrafo Œ∑.1 Y := by rfl
    _ = rewrittenTrafo Œ∑.1 X ‚â´ G.1.left.map f.1 := by
      exact nat
    _  =_ := by rfl
instance : Category (fibration B) where
  Hom := fun P Q ‚Ü¶ P ‚•§c Q
  id := fun P ‚Ü¶ by use ùüô P.1 ; intro œÜ hœÜ ; simp
  comp := fun {P Q R} F G ‚Ü¶ ‚ü® F.1 ‚â´ G.1 , fun {X} {Y} œÜ hœÜ ‚Ü¶ G.2 _ (F.2 _ hœÜ)‚ü©


instance {P Q : fibration B} : Category (P ‚ü∂ Q) where
  Hom := fun F G ‚Ü¶ F =>c G
  id := cartesianIdTrans
  comp := compCartTrans
  -- comp_id := ci

def forgetFibration {P Q : fibration B} : (‚ü® P ‚ü∂ Q , instCategoryHomFibrationToQuiverToCategoryStructInstCategoryFibration ‚ü© : Cat)  ‚•§ (P.1.left ‚•§ Q.1.left)  where
  obj := fun F ‚Ü¶ F.1.left
  map := fun f ‚Ü¶ f.1
@[simps] instance FiberToTotalSpace {B : Cat} {P : Over B} {I : B} : obj_over (P:=P.hom) I ‚•§ P.left where
  obj := fun X ‚Ü¶ X.1
  map := fun f ‚Ü¶ f.1

def extFunctor {C D : Cat} {F G : C ‚•§ D}
  (Œ∑ : F ‚ü∂ G)
 (isLevelwiseIdent : ‚àÄ X : C , isIdentity (Œ∑.app X) ) : F = G :=
  CategoryTheory.Functor.ext (fun X ‚Ü¶ ((isLevelwiseIdent X).choose))
  (fun {X} {Y} f ‚Ü¶ by
  let nat := Œ∑.naturality f
  rw[‚Üê Category.assoc]
  apply (CategoryTheory.Iso.eq_comp_inv (eqToIso _)).2
  have this : ‚àÄ X , Œ∑.app X = eqToHom _ := fun X ‚Ü¶ (isLevelwiseIdent X).choose_spec
  rw [‚Üê this X]
  rw [‚Üê nat]
  rw[ this Y]
  rfl
  exact ((isLevelwiseIdent Y).choose)
  )
def PShCat (B : Cat.{v‚ÇÅ , u‚ÇÅ} )  : Cat:= Bundled.of (B ·µí·µñ ‚•§ Cat.{s‚ÇÅ , t‚ÇÅ})
@[simp] lemma simptest {P Q R: fibration B} {F : P ‚•§c Q} {G : Q ‚•§c R} : (F ‚â´ G).1 = F.1 ‚â´ G.1 := rfl
@[simp] lemma compCheck {A : B} (F : P ‚•§c Q) (G : Q ‚•§c R) (X : obj_over A) : (G/A).obj ((F / A).obj X) = ((F ‚â´ G) / A).obj X := rfl

end FiberedCategories
