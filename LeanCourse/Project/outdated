OLD FUNCTIONS, NOT IMPORTANT
/-
lemma strongDiscreteness {A : B} (u : J ⟶ I ) (X : obj_over I)
  (L : liftOfAlong (P:=(domainOver A).hom) X u) :  ∃ (p :  L.Y.1 = (domainLift u X).Y.1) , L.φ.1 = eqToHom p ≫ (domainLift u X).φ.1  := by
  obtain ⟨ Y , φ ⟩ := L
  obtain ⟨φ , hφ⟩ := φ
  let p : Y.1 = (domainLift u X).Y.1 := by
    apply Subtype.ext
  use p
  have lol : φ.left = u
  have this : Y.1.hom = φ.left ≫ X.1.hom := by aesop
  simp
  apply Over.OverMorphism.ext
-/


-/
/-
def mappingOverHom {P Q : fibration B} (F : P ⟶ Q ) {J I} {u : J ⟶ I} {Y : P [J]} {X : P[I]} (φ : over_hom u Y X) :  over_hom u ((F / J).obj Y) ((F / I).obj X) := by
  use F.1.left.map φ.1
  let hφ := φ.2
  calc
      (Q.1).hom.map ((F.1).left.map φ.1) ≫ eqToHom (_ : Q.1.hom.obj ((F / I).obj X).1 = I)
    =  ((Q.1).hom.map ((F.1).left.map φ.1) ≫ eqToHom (symm (comm F))) ≫ eqToHom X.2 := by rw [Category.assoc] ; apply (_ ≫= · ) ; symm ; apply eqToHom_trans
  _ = (eqToHom (symm (comm F)) ≫ P.1.hom.map (φ.1)) ≫ eqToHom X.2 := by {
    have veryweird : (F.1.left ⋙ Q.1.hom).map φ.1 = (F.1.left ≫  Q.1.hom).map φ.1 := rfl
    apply (· =≫ _) ; rw [← Functor.comp_map , veryweird  ,  Functor.congr_hom (Over.w F.1) φ.1 , Category.assoc ,Category.assoc ,  eqToHom_trans , eqToHom_refl] ; aesop
  }
  _ = eqToHom (_) ≫ eqToHom (_) ≫ u := by rw [Category.assoc] ; apply (_≫= · ) ; apply φ.2
  _ = eqToHom (_ : (Q).1.hom.obj ((F / J).obj Y).1 = J) ≫ u := by rw [← Category.assoc] ; apply (· =≫ u) ; apply eqToHom_trans
  -- have this : u = Q.1.hom.map (F.1.left.map φ.1) := by sorry
/-
def cartesianMorphismToCartLift (P : Over B ) {I : B} {X : obj_over (P:=P.hom) I} { Y : P.1}  {φ : Y ⟶ X.1} (hφ : isCartesianMorphism  P φ) : cartesianLiftOfAlong X (P.hom.map φ ≫ eqToHom X.2) where
  Y := ⟨ Y , rfl⟩
  φ := ⟨ φ  , by aesop⟩
  isCart := by sorry --apply compPresCartesian -- sorry --hφ
-/

/-
def cartFunctorPresCartLifts {I : B} {X : obj_over (P:=P.1.hom) I} {u : J ⟶I } (L : cartesianLiftOfAlong X u) : cartesianLiftOfAlong ( (F / I).obj X) u := by
  let Fφ := mappingOverHom F L.φ
  let FXf :=  (F / I).obj X
  let Ff : isCartesianMorphism Q.1 (F.1.left.map L.φ.1) := F.2 L.φ.1 (cartLiftToCartMor L) --
  let FL' : cartesianLiftOfAlong (P:=Q.1.hom) FXf u  := by
      use ⟨ _ ,Fφ⟩
      let cartLift : cartesianLiftOfAlong _ (Q.1.hom.map  (F.1.left.map L.φ.1) ≫ eqToHom (_)) := cartesianMorphismToCartLift Q.1 Ff
      sorry
      --, by apply cartesianMorphismToCartLift ; sorry ⟩
  sorry
-/

/-
@[ext] def extCartLift {J I} (u : J ⟶ I) (X : obj_over (P:=P) I) (r s : cartesianLiftOfAlong X u) (q : r.1 = s.1) : r = s
  := by sorry
-/
